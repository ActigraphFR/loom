\documentclass{llncs}
%
\usepackage{amssymb}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
  decorations.pathreplacing,decorations.pathmorphing,shapes,%
  decorations.text, fit, shapes.geometric, hobby, backgrounds, calc,
  matrix,shapes.symbols,plotmarks,decorations.markings,shadows}
%
\begin{document}
%
\mainmatter              % start of the contributions
%
\title{Automatic Generation of Transit Maps}
%
\titlerunning{Automatic Generation of Transit Maps}
%
\author{Hannah Bast\inst{1} \and Patrick Brosi\inst{1} \and
Sabine Storandt\inst{2}}
%
\authorrunning{Hannah Bast et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Hannah Bast, Patrick Brosi, Sabine Storandt}
%
\institute{University of Freiburg (Germany)\\
\email{\{bast, brosi\}@informatik.uni-freiburg.de}
\and
JMU W\"urzburg (Germany)\\
\email{storandt@informatik.uni-wuerzburg.de}
}

\maketitle              % typeset the title of the contribution

\begin{abstract}
TODO
\keywords{computational geometry, graph theory, optimization}
\end{abstract}
%
\section{Introduction}
%

\begin{itemize}
\item mention usefulness, mention bad google maps etc
\item mention that we know of no publication adressing the MCLM or the drawing of metro maps that uses real-world data
\item mention that we not only want to generate schematic maps, but maps that resemble the real-world vehicle paths as closely as possible (e.g. to serve as a map overlay)
\end{itemize}

\subsection{Problem Definition}

Let $L$ by a set of unique transit lines and w.l.o.g. $l \in \mathbb{N}$. We call an undirected graph $T = (V, S)$ with vertices $v = (p_v, \sigma_v)$ and segments $s = (u, v, L(s), \tau_s)$ a transit graph. Each $v$ has a position $p_v \in \mathbb{R}^2$. Furthermore we assign each segment $s$ a polygonal chain $\tau_s = (p_1, ..., p_n), p_i \in \mathbb{R}^2$ which describes the geometrical path a segment takes through the plane. For each $s$, we impose $p_1 = p_u$ and $p_n = p_v$, that is the polygonal chain has to start and end at the position of the segment's start and end node. $L(s)$ is the (ordered) set of lines that traverse $s$. Finally, we assign each node a role $\sigma_v \in {0, 1}$, where $\sigma_v = 1$ means that $v$ is a real station node and $\sigma_v = 0$ that $v$ is only a spatial topology node.

$G$ can be understood as an embedding of an undirected multigraph $G = (V, E)$, where each line $l$ traversing a segment $s$ is transformed into a single edge. It can also be understood as an embedding of a set of $\mathbb{L}$ polygonal chains.

The goal is to render $T$ in a way that resembles a modern transit map.

We chose this definition because it proved to be useful during line-ordering optimization as well as during map rendering (see ??). It also resembles the intuitive understanding of a transit map.


TODO: mention in further work (or somewhere more appropriate) that it is very easy (as we have done it) to apply our approach to a directed graph.

%
\subsection{Related Work}
%
Fink and Pupyrev show that MLCM is NP-hard in \cite{fink:pupyrev}.
%
\subsection{Contribution}
%
(TODO)
\begin{itemize}
\item We introduce an approach for drawing transit maps that can be used with arbitrary input data in the GTFS format
\item ... describe a simple line-sweeping approach to extract the spatial topology graph of a set of (partially overlapping) polylines
\item ... describe a baseline ILP for solving the metro line crossing problem (MLCM)
\item ... describe a improvied ILP for solving (MLCM) and add a simple extension that also minimizes line-splittings (and subsequently, the periphery problem)
\item ... describe some heuristics for placing inevitable crossings in a asthecitally pleasing way
\item ... describe the reduction of the minimization problem to core problem graphs which simplifies the problem
\end{itemize}

%
\section{Spatial Topology Extraction}
%

Real-world public transit data is usually given as a set of stations (with geographical positions) and a set of vehicle routes, each consisting of some meta-information (line number, color, ...) and a list of stop / time pairs representing the vehicle's schedule. In many cases, the geographical path the vehicle takes through the real world is also given. In recent years, the General Transit Feed Specification (GTFS) has become the dominant format for exchanging public transit schedules, but there are still many proprietary formats (e.g. HACON, EFA etc.) which can be converted to GTFS with moderate effort. The difference between most of the formats is mainly syntactical.

This data is essentially an embedding of a transit graph, but with two major problems:
\begin{enumerate}
\item there may be many (possibly thousands of) edges between two station nodes, with different polygonal chains as paths
\item topological nodes are missing in most cases (TODO: mention possibility to store this in GTFS)
\end{enumerate}

We transform this data into a well-formed transit graph $G$ by using a simple line-sweeping algorithm to collapse (partially) similar vehicle paths into single segments. Topological nodes are inserted on-the-fly.


\begin{figure}[h]
\centering
	\begin{tikzpicture}[scale=1.5]
   \tikzstyle{node}=[inner sep=1pt, circle, draw=black, solid, fill=white];
   \tikzstyle{anc}=[inner sep=0.3pt, circle, draw=black, solid, fill=black];
   \draw[->] (-1.2,0) -- (4.2,0) node[right] {$x$};
   \draw[->] (-1,-0.2) -- (-1,2.2) node[above] {$y$};


	\draw (-0.5,1) -- (-0.25, 0.95) node[anc]{} -- (-0.15, 0.93) node[anc]{}
		-- (-0, 0.98) node[anc]{} -- (0.1, 0.97) node[anc]{} -- (0.41, 0.94) node[anc]{} -- (0.51, 0.97) node[anc]{}
		-- (1.11, 0.99) node[anc]{} -- (1.31, 1.06) node[anc]{} -- (1.41, 1.09) node[anc]{} -- (1.59, 1.1) node[anc]{}
		-- (1.77, 1.04) node[anc]{} -- (1.97, 1.01) node[anc]{} -- (2.07, 1.02) node[anc]{} -- (2.77, 0.94) node[anc]{}
		-- (2.77, 0.94) node[anc]{} -- (2.97, 0.84) node[anc]{} -- (3.17, 0.54) node[anc]{} -- (3.27, 0.24) node[node]{\tiny B};

	\draw (-0.5,1) -- (-0.1, 1.05) node[anc]{} -- (0.2, 1.03) node[anc]{} -- (0.35, 1.06) node[anc]{} -- (0.45, 1.096) node[anc]{}
		-- (0.55, 1.14) node[anc]{}
		-- (0.7, 1.18) node[anc]{}
		-- (0.8, 1.2) node[anc]{}
		-- (0.9, 1.2) node[anc]{}
		-- (1.1, 1.15) node[anc]{}
		-- (1.25, 0.985) node[anc]{}
		-- (1.35, 0.965) node[anc]{}
		-- (1.45, 0.967) node[anc]{}
		-- (1.6, 0.98) node[anc]{}
		-- (1.79, 1.12) node[anc]{}
		-- (2.02, 1.09) node[anc]{}
		-- (2.32, 1.07) node[anc]{}
		-- (2.52, 1.02) node[anc]{}
		-- (2.92, 1.1) node[anc]{}
		-- (3.12, 1.3) node[anc]{}
		-- (3.19, 1.5) node[anc]{}
		-- (3.25, 1.8) node[node]{\tiny C};


    \draw[dotted] (-0.5,0) node[below] {$d_0$} -- (-0.5,2) ;
    \draw[dotted] (-0.2,0) node[below] {$d_1$} -- (-0.2,2) ;
    \draw[dotted] (0.4,0) node[below] {$d_3$} -- (0.4,2) ;
    \draw[dotted] (0.7,0) node[below] {$d_4$} -- (0.7,2) ;
    \draw[dotted] (1,0) node[below] {$d_5$} -- (1,2) ;



	\node at (-0.5, 1)[node]{\tiny $A$};








	;

\end{tikzpicture}

\caption{Line sweeping algorithm for spatial topology extraction}
\end{figure}

The process can be sped up by indexing every linear segment of every vehicle path in a geometric index (for example, an R-Tree), making for a better lookup time of nearby segments.


\subsection{Meta nodes}

%
\section{Line Ordering Optimization}
%




%
\subsection{Local Search}
%
(maybe dont mention this)
%
\subsection{Baseline ILP}
%
%
\subsection{Improved ILP}
%
The $\mathcal{O}(|S|M^{2})$ variables in the baseline ILP seem to be reasonable, as indeed $\Omega(|S|M^{2})$ crossings could occur. But the $\mathcal{O}(|S|M^{6})$ constraints are due to enumerating all possible position inversions explicitly. If on the other hand the statement \emph{position of A on $s$ is smaller than the position of B} would be efficiently checkable, the number of constraints could be reduced. To have such an oracle, we first modify the line-position assignment constraints. Subsequently, we use  the oracle to encode inversions with fewer constraints.
\subsubsection{Alternative line-position assignment}
Instead of a decision variable which encode the exact position of a line in a segment as before, we know use $x_{sl\leq p} \in \{0,1\}$ which is $1$ if the position of $l$ in $s$ is $\leq p$ and $0$ otherwise. To enforce a unique position, we use the constraints:
$$\forall l \in L(s) \forall p \in \{1, \cdots, |L(s)|-1\}: x_{sl\leq p} \leq x_{sl\leq p+1}$$
This ensures that the sequence can only switch from $0$ to $1$, and this exactly once. To make sure that at some point a $1$ appears and that each position is occupied by exactly one line, we additionally introduce the following constraints:
$$\forall p \in \{1, \cdots, |L(s)|\}: \sum_{l \in L(s)} x_{sl\leq p} = p$$
So exactly for  one line $x_{s.\leq 1} =1$ is true, for two lines $x_{s.\leq 2} = 1$ (of which one has to fulfill $x_{s.\leq 1} =1$) and so on.
\subsubsection{Crossing Oracle}
We reconsider the example from \ref{SEC:ac}, left. Before, we enumerated all possible positions which induce a crossing for $A, B$ at the transition from $s$ to $s'$. But it would be sufficient to have variables which tell us whether the position of $A$ is smaller than the position of $B$ in $s$, and the same for $s'$, and then compare those variables. For a line pair $(A,B)$ on segment $s$ we call the respective variables $x_{sA>B}, x_{sA<b} \in \{0, 1\}$. Since we introduce these variables for each line pair in $s$, $x_{sA<B}$ will re-appear as $x_{sB>A}$, so we only need $x_{sA>B}$. To get the desired value assignments, we add the following constraints:
$$\sum_{p=1}^{|L(s)|} x_{sA\leq p} - \sum_{p} x_{sB\leq p} + x_{sA>B} M \geq 0$$
$$x_{sA>B} + x_{sB>A}=1$$
The equality constraints make sure that not both $x_{sA>B}$ and $x_{sB>A}$ can be $1$. If the position of $A$ is smaller than the position of $B$, then more of the variables corresponding to $A$ are $1$, hence the sum over all is higher. So if we subtract the sum for $B$ from the sum for $A$ and the result is $\geq 0$, we know the position of $A$ is  smaller and $x_{sA>B}$ can be $0$. Otherwise, the difference is negative, and we need to set $x_{sA>B}$ to $1$ to fulfill the inequality. It is then indeed fulfilled for sure as the position gap can never exceed the number of lines per segment.

To finally decide if there is a crossing, we would again like to have a decision variable $x_{ss'AB} \in \{0,1\}$ which is $1$ in case of a crossing and $0$ otherwise -- and minimize the sum of all such variables in the objective function. The constraint $$abs(x_{sA<B}-x_{s'A<B}) - x_{ss'AB} \leq 0$$ would realize this, as either $x_{sA<B} = x_{s'A<B}$ (both $0$ or both $1$) and then $x_{ss'AB}$ can be $0$, or they are unequal and hence the absolute value of their difference is $1$, enforcing $x_{ss'AB}=1$ to fulfill the $\leq 0$ condition. As absolute value computation can not be part of an ILP we use the following replacements:
$$x_{sA<B} - x_{s'A<B} - x_{ss'AB} \leq 0$$
$$-x_{sA<B} + x_{s'A<B} - x_{ss'AB} \leq 0$$
If the values are equal, nothing changes in the argumentation. If the values are unequal, either the upper or the lower constraint will produce a $1$ as the sum of the first two terms, enforcing $x_{ss'AB}=1$ as desired.

\subsection{Placement of Inevitable Crossings}

\subsection{Preventing Line Partner Splitting}
So far, we only optimized for the number of line crossings. This may not lead to the solution that is most visually pleasing. Consider the example given in Figure~\ref{FIG:linesplitting}. The number of line crossings (1) is indeed minimized in the left example. However, the intuitive information that A and B continue together after x is lost. In the right example, this information is preserved, but the number of line crossings is now 2.

\begin{figure}
  \centering
	$	\vcenter{\hbox{\includegraphics[width=0.36\textwidth]{examples/splitting_example_nonopt.pdf}}}$
	\hspace{10mm}
$	\vcenter{\hbox{\includegraphics[width=0.36\textwidth]{examples/splitting_example.pdf}}}$
	\caption{Left: optimized only for line crossings, Right: optimized also for line splittings}
	\label{FIG:linesplitting}
\end{figure}

A related problem can be seen in Figure TODO. Both solutions have the same number of line crossings (2), but the left one clearly looks better, because the crossing is done in one pass. In both cases, we could adress the problem by punishing the separation of lines. For two adjacent segments $s$ and $s'$ and a line pair $(A, B$) that continues from $s$ to $s'$, if $A$ and $B$ were placed next to each other in $s$ (were partners in $s$) but not anymore in $s'$, we want to add some penalty to the objective function. For this, we introduce a variable $x_{sA\|B} \in \{0, 1\}$. Let $p_{sA}$ be the position of $A$ in $s$ and $p_{sB}$ the position of $B$ in $s$. We want $s_{sA\|B}$ to be $1$ if $\left|p_{sA} - p_{sB}\right| = 0$ (if they occur next to each other) and $1$ otherwise. To get the desired assignments, we add the following constraints per line pair in $s$:

$$\sum_{p=1}^{|L(s)|} x_{sA\leq p} - \sum_{p} x_{sB\leq p} - x_{sA\|B} M \leq 1$$
$$\sum_{p=1}^{|L(s)|} x_{sB\leq p} - \sum_{p} x_{sA\leq p} - x_{sA\|B} M \leq 1$$

If $p_{sA} = p_{sB}$, then the difference of the sums in both constraints is 0. If $|p_{sA} - p_{sB}| = 1$, then the sum difference in both constraints is $\leq 1$. If $|p_{sA} - p_{sB}| > 1$, then either the first or the second constraint enforces $x_{sA\|B} = 1$. To prevent the trivial solution where $x_{A\|B}$ is 1 for all line pairs, we introduce the following additional constraint per segment:

$$\sum_{l \in L(s)}\sum_{l' \in L(s)} x_{sl\|l'} \leq |L(s)|^2 - 3|L(s)| - 2$$

as indeed the maximal number of line pairs in $s$ (excluding lines paired with themselves) is $|L(s)|^2 - |L(s)$ and the number of $x_{sl\|l'}$ in $s$ that are 0 is exactly $2|L(s)| - 2$ (each line is next to its two neighbors, but the first and last line only have 1 neighbor). A fixed constraint is not necessary here, however, because the lower bound is already provided by the line pair constraints (?) and (?).

(Mention the special case of the MLCM-P periphery constraint the above constraints handle out-of-the-box).



%
\subsection{Core problem graph}
%

An inevitable crossing (or splitting) between two lines $j$ and $k$ can only occur if there is at least one node with one of the following two properties:
\begin{enumerate}
\item $v$ is adjacent to segments $s : j \not\in L(s) \land k \in L(s')$ and $s' : j \in L(s') \land k \not\in L(s)$.
\item $|{s \in adj(v) : j \in L(s) \land i \in L(s)}| > 2$
\end{enumerate}
Proof (sketch): if no such $v_jk$ exists, then it holds for all nodes $v \in V$ that $j$ and $k$ either both travel through $v$ on the same two segments or they don't travel together through $v$ at all (or only one of them). In the latter case, no crossing (or splitting) will occur and we can thus disregard it, which leaves us only with the former case. But if $j$ and $k$ travel through all nodes in which a crossing could occur together on the same two segments, then the relative order of $j$ and $k$ does not matter anymore - we just combine $j$ and $k$ into a new line $i$ and assign $j$ and $k$ an arbitrary (either $(j,k)$ or $(k, j$) global ordering.

We call nodes that comply to (1) for a line pair $A = \{j, k\}$ a liaison node for $j$ and $k$ and nodes that comply to (2) a T-node for $j$ and $k$. Additionally, we call a node that is a liaison and/or T-node for at least one line pair an \textbf{intersection node} and a node in which one or more lines end a \textbf{terminus node}.

Using the above, we can now greatly simplify the input graph prior to optimization with the following steps:

\begin{enumerate}
\item combine lines that always occur together in a segment and for which no intersection or T-node exists into a single line with a global, arbitrary relative ordering
\item delete each node with degree 2 (adjacent to segments $s = (u, v)$ and $s' = (v, w)$) and $L(s) = L(s')$ and combine $s$ and $s'$ into a single new segment $ss' = (u, w)$ with $L(ss') = L(s) = L(s')$ . Note that such a node can never be a terminus node or an intersection node.
\end{enumerate}

Since we never delete an intersection node, these operations will not affect the optimality of the found solution. In practice, they will "move" line crossings to nodes where a new line is introduced to an existing thread of lines (liaison nodes) or to nodes where topological changes are introduced to the network (T-nodes). For real-world networks, this is asthecitally desirable and can significantly reduce the number of ILP variables and constraints.

This core problem graph can be further prepared for optimiziation by splitting it into ordering-relevant connected components using the following rules:

\begin{enumerate}
	\item cut each segment $s = (u, v)$ with $|L(s)| = 1$ into two segments $s' = (u, v')$ and $s'' = (v'', v)$. Note that $v'$ and $v''$ are not connected.
	\item replace each segment $s = (u, v)$ where $v$ is a terminus node for each $l \in L(s)$ with a segment $s' = (u, v'$ where $v'$ is only connected to $s'$. Delete $s$ from the adjaceny list of $v$.
	\item remove each segment $s = (u, v)$ where $u$ and $v$ are termini for all $l \in L(s)$
\end{enumerate}

The line-ordering optimization can now be run independently on each connected component of the core problem graph, reducing the size of the ILPs that have to be solved and opening the way for parallelization.

\begin{figure}[h]
\centering
	\tikzstyle{graphnode}=[inner sep=2pt, circle, draw=black, solid, fill=white]

\begin{tikzpicture}[scale=0.9]
	\foreach \place/\x in {{(9.5,4)/A}, {(11.3,3)/B},{(11,1.5)/C},{(9,2.3)/D}, {(8, 4)/E}, {(6.3, 3.3)/F}, {(8.3, 1)/G}, {(7.3, 2.5)/H}, {(6.5, 1)/I}}
	\node[graphnode] (\x) at \place {$\x$};

	\draw (A) .. controls (10.5,4.3) and (11, 4) .. (B) node [midway, above right] {$abc$};
	\draw (B) .. controls (11.5,2) and (11.5, 2).. (C) node [midway, above left] {$abc$};
	\draw (C) .. controls (10, 1) and (10.3, 2.5) .. (D) node [midway, below left] {$ab$};
	\draw (A) .. controls (10.3, 3) and (10.4, 2.7) .. (D) node [midway, right] {$c$};
	\draw (E) .. controls (9, 3.8) .. (A) node [midway, below] {$def$};
	\draw (D) .. controls (8, 2.3) .. (H) node [midway, below] {$ab$};
	\draw (D) .. controls (8.6, 1.8) .. (G) node [midway, right] {$e$};
	\draw (G) .. controls (7.35, .8) .. (I) node [midway, below] {$e$};
	\draw (I) .. controls (6.7, 2.1) .. (H) node [midway, below right] {$f$};
	\draw (F) .. controls (5.7, 2.3) .. (I) node [midway, right] {$ef$};
	\draw (F) .. controls (7.3, 3.5) .. (E) node [midway, above] {$ef$};
	\draw (H) .. controls (7.6, 3.3) .. (E) node [midway, right] {$d$};

\end{tikzpicture}
	\hspace{0.6cm}
	\begin{tikzpicture}[baseline=1.2cm]
	\newcommand{\highlight}[3]{
		\path [line cap = round, line join = round, line width = #1, draw = #2!40] #3;

		\pgfmathsetmacro{\innerlinewidth}{0.95 * #1}
		\path [line cap = round, line join = round, line width = \innerlinewidth, draw = #2!15] #3;
	}

	\foreach \place/\x in {{(9.5,4)/A}, {(10.3,2.3)/C},{(9,2.3)/D}, {(7, 4)/E}, {(7.9, 3.1)/H}, {(6.5, 2)/I}}
	\node[graphnode] (\x) at \place {$\x$};

	\draw (A) -- (C) node [midway, above right] {$xc$};
	\draw (C) -- (D) node [midway, below left] {$x$};
	\draw (A) -- (D) node [midway, right] {$c$};
	\draw (E) -- (A) node [midway, above] {$def$};
	\draw (D) -- (H) node [midway, below] {$x$};
	\draw (D) -- (I) node [midway, below] {$e$};
	\draw (I) -- (H) node [midway, below] {$f$};
	\draw (E) -- (I) node [midway, above left] {$ef$};
	\draw (H) -- (E) node [midway, right] {$d$};

	\begin{pgfonlayer}{background}
		\highlight{14mm}{blue}{(I) -- (E)}
		\highlight{14mm}{red}{(A) -- (C)}
	\end{pgfonlayer}

\end{tikzpicture}

	\caption{Left: transit graph $G$ with lines $a, b, c, d, e, f$, Right: core optimization graph with highlighted ordering-relevant connected components with more than 1 node; $ab$ was collapsed into $x$.}
\end{figure}

\section{Rendering}

TODO: short explanation of parallel line rendering, node front expansion for non-station nodes, explain bezier curve and explain degeneration to circle arc

\section{Evaluation}


\subsection{Optimization Results}

\subsection{Aesthetical Evaluation}


%
% ---- Bibliography ----
%
\begin{thebibliography}{5}
%
\bibitem[1]{fink:pupyrev}
Fink, M., Pupyrev, S.:
Metro-Line Crossing Minimization: Hardness, Approximations, and Tractable Cases.
\textit{Graph Drawing}, vol. 8242, pp. 328-339. 2013.

\end{thebibliography}
\end{document}
